---
title: 在赶地铁时学会生成器
updated: 2018-06-30 17:26:21
---

### 目标读者
- 不了解什么是生成器。
- 了解生成器，但不清楚它的应用场景。

### 本篇文章你会收获
- 什么是生成器？
- 生成器的使用。
- 生成器的最佳应用场景。

### 什么是生成器？
在了解生成器之前，让我们先理解什么是迭代、可迭代对象、迭代器。

#### 迭代
使用循环来遍历某个对象时，这个过程本身就叫做迭代。

```python
a = [1, 2, 3]

for i in a:  # 这个过程就叫做迭代
    print(i)
```

#### 可迭代对象
只要该对象可以被迭代，那它就是一个可迭代对象。

```python
a = [1, 2, 3]  # 列表a就是一个可迭代对象，因为它可以被下面的for循环迭代

for i in a:
    print(i)
```

#### 迭代器
迭代器就是一个可迭代对象。但它可以一次返回一个元素，当没有元素可以被返回时会引发StopIteration异常。

```python
a = [1, 2, 3]  # 列表a就是一个可迭代对象。但目前，它还不是一个迭代器

a = iter(a)  # 此时的列表a已经变成了一个迭代器
print(next(a))  # 这会打印1
print(next(a))  # 这会打印2
print(next(a))  # 这会打印3
print(next(a))  # 这会引发StopIteration异常，因为列表a中已经没有下一个元素了
```

`iter()`根据一个可迭代对象返回一个迭代器对象。`next()`返回迭代器的下一个元素，在没有下一个元素时则会触发StopIteration异常。

### 这就是生成器
生成器也是一种迭代器，但是你只能对其迭代一次。这是因为它们并没有把所有的值存在内存中，而是在运行时生成值。

### 生成器的使用
使用生成器的方法有两种，第一种是生成器表达式。

```python
a = (i * i for i in range(3))

for i in a:
    print(i)  # 这会依次打印0、1、4。同时也证明了生成器也是一种迭代器

print(next(a))  # 这会引发StopIteration异常，因为列表a中已经没有下一个元素了
```

乍一看，第一行代码很像推导式，可惜，它不是（这不是功夫里包租婆说的台词吗？！哇哈哈哈）。
你肯定会问a为什么就变成了一个生成器呢？我的答案是甲鱼的臀部，龟腚。你要不信可以调用`type()`函数看一下它是什么类型，不过我觉得你这是多此一举。

第二种实现方式是在函数中使用`yield`关键字，叫做生成器函数，如下所示。

```python
def a():
    for i in range(3):
        yield i


for i in a():
    print(i)  # 这会依次打印0、1、2
```

函数a还是当年的那个函数a，只不过它返回的是个生成器。

`yield`和`return`很像，都是一个妈生的，只不过`yield`是个女孩随它妈，`return`是个男孩且随他爸。`yield`比较温柔、细心，在它返回1后，还可以返回2、3、4。而`return`比较刚毅，有个性，返回1后，就啥也不管了。

```python
def a():
    i = 1
    while i < 5:
        yield i
        i += 1


a = a()
print(next(a))  # 这会打印1
print(next(a))  # 这会打印2
print(next(a))  # 这会打印3
print(next(a))  # 这会打印4


def b():
    i = 1
    while i < 5:
        return i
        i += 1  # 使用了return后，这行代码不会被执行


b = b()
print(b)  # 只会打印1
print(b)  # 还是会打印1
```

### 生成器的最佳应用场景
生成器的最佳应用场景就是你不想同一时间将所有计算结果分配到内存中。
下面是一个计算一百万位的斐波那契数的生成器：

```python
def f():
    a = b = 1
    for i in range(1000000):
        yield a
        a, b = b, a + b


for i in a():
    print(i)
```

但之前如果我们这样实现的话就会造成你的电脑内存瞬间暴涨，进而卡死，而你只能强制重启（来吧，我非常期待你重启一次）。

```python
def f():
    a = b = 1
    result = []
    for i in range(1000000):
        result.append(a)
        a, b = b, a + b
    return result


print(f())
```

### 笔记
`iter(iterable)`：根据一个可迭代对象返回一个迭代器对象。
`next(iterator[, default])`：返回迭代器的下一个元素。default用于设置在没有下一个元素时返回该默认值，如果不设置，又没有下一个元素则会触发StopIteration异常。
`yield`：只能在函数中使用，类似return关键字，只是这个函数返回的是个生成器。
`range(start, stop[, step])`：从start（包括）开始到stop停止（不包括）生成一个整数序列，step是步长，默认为1，并返回一个生成器对象。
